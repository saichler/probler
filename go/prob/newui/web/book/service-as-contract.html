<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#fdfbf7">
    <meta name="description" content="Service as a Contract, Enforced by Concurrency | Radical Simplicity for Humans by Sharon Aicler">
    <meta name="author" content="Sharon Aicler">
    <title>Service as a Contract, Enforced by Concurrency | Radical Simplicity for Humans</title>
    <link rel="stylesheet" href="css/book.css">
</head>
<body>
    <button class="mobile-nav-toggle" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
    </button>
    <div class="sidebar-overlay"></div>

    <div class="site-container">
        <nav class="sidebar" role="navigation" aria-label="Table of Contents">
            <header class="site-header">
                <h1 class="book-title">Radical Simplicity<br>for Humans</h1>
                <p class="book-subtitle">Layer 8</p>
                <div class="author-info">
                    <p>Sharon Aicler</p>
                    <p><a href="mailto:saichler@gmail.com">saichler@gmail.com</a></p>
                </div>
                <div class="sponsor-button">
                    <iframe src="https://github.com/sponsors/saichler/button" title="Sponsor saichler" height="32" width="114" style="border: 0; border-radius: 6px;"></iframe>
                </div>
            </header>

            <h2 class="nav-title">Contents</h2>
            <ul class="chapter-list">
                <li><a href="book.html">Home</a></li>
                <li><a href="about.html">About the Author</a></li>
                <li><a href="introduction.html">Introduction</a></li>
                <li><a href="thoughts.html">Thoughts</a></li>
                <li><a href="ground-rules.html">Ground Rules</a></li>
                <li><a href="architecture.html">Architecture Is the Alignment Mechanism</a></li>
                <li><a href="failure-modes.html">Failure Modes</a></li>
                <li><a href="economics.html">Economics</a></li>
                <li><a href="security.html">Security</a></li>
                <li><a href="networking.html">Networking</a></li>
                <li><a href="serialization.html">Serialization</a></li>
                <li><a href="model-agnostic-runtime.html">Model-Agnostic Runtime</a></li>
                <li><a href="service-as-contract.html" class="active">Service as a Contract</a></li>
                <li><span class="coming-soon">API &amp; Query Language</span></li>
                <li><span class="coming-soon">Object Relation Mapping</span></li>
                <li><span class="coming-soon">Web Server</span></li>
                <li><span class="coming-soon">Quality</span></li>
                <li><span class="coming-soon">Migration</span></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="content-wrapper">
                <article>
                    <h1>Service as a Contract, Enforced by Concurrency</h1>

                    <blockquote>
                        <p>The phrase "As a Service" is widely used and rarely understood.</p>
                    </blockquote>

                    <p>For most software engineers and architects, serviceability is not a first-class design concern. It is not taught as part of computer science curricula, nor is it emphasized during professional growth.</p>

                    <p><strong>As a result, systems are often designed without an explicit serviceability mindset.</strong></p>

                    <hr>

                    <h2>The Serviceability Mindset</h2>

                    <p>A <strong>serviceability mindset</strong> is an architectural approach that treats operational behavior, correctness under concurrency, failure handling, recovery, and evolution; as part of the service contract, not as an afterthought.</p>

                    <p>Rather than assuming services will be managed externally through tooling and procedures, a serviceability mindset requires that services declare their guarantees up front and relies on the platform to enforce them.</p>

                    <p>In this model, correctness, predictability, and diagnosability are properties of the architecture itself, not responsibilities deferred to operators or runtime intervention.</p>

                    <p>With the rise of microservices, this gap became more visible. While systems are broken into services, Service Level Agreements (SLAs) are rarely defined, modeled, or enforced at design time.</p>

                    <p>This leads to a design failure on day one.</p>

                    <p>Without SLAs, services are merely distributed components. They expose APIs, <strong>but they do not provide guarantees.</strong></p>

                    <p>In Layer 8, serviceability is foundational.</p>

                    <p>An SLA is not documentation. It is not an operational afterthought. It is a core architectural contract.</p>

                    <p>Layer 8 treats SLA as a first-class concept, enforced by the platform and used to drive radical simplicity in system design.</p>

                    <hr>

                    <h2>What is a Service?</h2>

                    <p>One of the most common misconceptions in modern software architecture is the belief that a service is a process, a container, or a pod.</p>

                    <p><strong>It is not.</strong></p>

                    <p>Whatever runs inside a process is not the service. Treating runtime artifacts as services is a primary source of accidental complexity.</p>

                    <p><strong><em>It forces architects to solve problems that should not exist in the first place.</em></strong></p>

                    <p>This misconception leads directly to:</p>

                    <ul>
                        <li>unnecessary coupling,</li>
                        <li>fragile scaling strategies,</li>
                        <li>and lifecycle confusion.</li>
                    </ul>

                    <p>Layer 8 uses a different definition.</p>

                    <p>In Layer 8, a Service encapsulates the lifecycle of a <strong>Prime Object</strong>.</p>

                    <h3>Prime Object</h3>

                    <blockquote>
                        <p>A Prime Object is the root of a nested model with an independent lifecycle and support for creating, reading, updating, and deleting state, and it defines the unit of concurrency ownership that allows Layer 8 to enforce concurrency at the architectural level rather than in application code.</p>
                    </blockquote>

                    <p>If an object can be created, updated, queried, and deleted independently, it qualifies as a Prime Object and therefore defines a service boundary.</p>

                    <p>Layer 8 adopts the commonly understood RESTful semantics and uses POST, PUT, PATCH, DELETE, and GET as the basic interaction interface between other services and its Prime Object.</p>

                    <p><strong>It is important to note:</strong> This service interface is not exposed to the outside world. It is used only for service-to-service interaction within the same Virtual Network.</p>

                    <h3>Logical Services vs Runtime Artifacts</h3>

                    <p>In Layer 8, a service is a logical construct, not a runtime artifact.</p>

                    <p>A logical service is defined by its ownership of a Prime Object, its identity model, and its declared Service Level Agreement. It represents a contract: how the system behaves under concurrency, failure, and evolution.</p>

                    <p>Processes, containers, and pods are runtime artifacts. They are execution units created to host service logic, but they are not the service itself. They can be restarted, replaced, rescheduled, or scaled without changing the service's identity or guarantees.</p>

                    <p>Confusing runtime artifacts with services forces architects to solve lifecycle, scaling, and concurrency problems at the infrastructure level. Layer 8 avoids this by treating runtime artifacts as interchangeable participants in a single logical service, whose behavior is defined by <strong>contract rather than deployment.</strong></p>

                    <h3>Example: Single Service</h3>

                    <p>In the following example, there is only one service: Employee.</p>

                    <p>The Address does not have an independent lifecycle. It does not exist outside the Employee model and therefore does not define its own service.</p>

<pre><code>message Employee {
  string id = 1;
  Address addr = 2;
}

message Address {
  string line1 = 1;
  string line2 = 2;
  string line3 = 3;
}</code></pre>

                    <h3>Example: Two Services</h3>

                    <p>In the next example, Address has its own lifecycle. It can be created, updated, and deleted independently.</p>

                    <p>As a result, it becomes its own service.</p>

<pre><code>message Employee {
  string id = 1;
  string addrId = 2;
}

message Address {
  string addrId = 1;
  string line1 = 2;
  string line2 = 3;
  string line3 = 4;
}</code></pre>

                    <p>This method of identifying services based on lifecycle ownership has proven to be a major architectural enabler.</p>

                    <p>It allows Layer 8 to provide generic support for:</p>

                    <ul>
                        <li>concurrency,</li>
                        <li>redundancy,</li>
                        <li>high availability,</li>
                        <li>and horizontal scaling,</li>
                    </ul>

                    <p>without introducing service-specific logic, while allowing a single service to span multiple processes and present itself as a single logical service.</p>

                    <p>These properties emerge naturally from the service definition and will be explored further in the rest of this chapter.</p>

                    <hr>

                    <h2>Concurrency and Transactions</h2>

                    <p>A crucial step in designing a service is defining its <strong>Service Level Agreement (SLA)</strong>.</p>

                    <p>If this step is skipped, postponed, or treated as an afterthought, failure is almost guaranteed.</p>

                    <p>An SLA is a business contract. If expectations are not defined up front, consumers will define them instead, and those expectations will usually grow without bounds.</p>

                    <p><strong>To prevent this, Layer 8 enforces SLA awareness.</strong></p>

                    <p>An SLA is not optional. It is a required input for service activation.</p>

                    <p>A service cannot start without declaring how it behaves.</p>

                    <h3>Stateless or Stateful</h3>

                    <p>The first decision a service must make is whether it is stateless or stateful. Assume there are three instances of a service running in three different processes.</p>

                    <p>If one instance crashes and restarts, ask the following question:</p>

                    <blockquote>
                        <p>Can the restarted instance immediately serve requests without synchronizing with the other two and without breaking correctness?</p>
                    </blockquote>

                    <p>If the answer is yes, the service is <strong>stateless</strong>.</p>
                    <p>If the answer is no, the service is <strong>stateful</strong>.</p>

                    <p>This decision directly impacts concurrency, recovery, and transaction semantics.</p>

                    <h3>Service Item</h3>

                    <p>We established earlier that a service encapsulates a <strong>Prime Object</strong>.</p>

                    <p>The next question is: what uniquely identifies an instance of that Prime Object?</p>

                    <blockquote>
                        <p>Within the Prime Object, one or more attributes must define identity.</p>
                    </blockquote>

                    <p>These attributes form the Service Item key.</p>

                    <p>Concurrency, routing, and transactional guarantees are all applied relative to this identity.</p>

                    <h3>Stateful Concurrency Methods</h3>

                    <blockquote>
                        <p>For stateful services, the SLA must define the concurrency model.</p>
                    </blockquote>

                    <p>Layer 8 supports the following patterns.</p>

                    <h4>Best Effort</h4>

                    <p>Multiple instances may receive requests.</p>

                    <p>When an instance processes a request, it acknowledges completion to the caller and makes a best effort to propagate the update to its peers.</p>

                    <p>This model favors availability and low latency, but allows temporary inconsistency.</p>

                    <h4>Transactional</h4>

                    <p>A single instance is elected as the leader.</p>

                    <p>All requests are routed through the leader, which coordinates updates with its followers.</p>

                    <p>When the leader acknowledges completion, all peers are already synchronized.</p>

                    <p>This model favors consistency over availability.</p>

                    <h4>Replication Count X</h4>

                    <p>A single instance is elected as the leader.</p>

                    <p>Requests are routed to the leader, which coordinates updates with a defined number of followers.</p>

                    <p>Completion is acknowledged only after X peers have successfully synchronized the data.</p>

                    <p>This model allows precise control over the balance between:</p>

                    <ul>
                        <li>consistency,</li>
                        <li>availability,</li>
                        <li>and latency.</li>
                    </ul>

                    <h3>SLA Choices and Observable Behavior</h3>

                    <p>The following table summarizes how SLA declarations in Layer 8 translate directly into observable system behavior.</p>

                    <div class="table-wrapper">
                        <table>
                            <thead>
                                <tr>
                                    <th>SLA Choice</th>
                                    <th>Declaration</th>
                                    <th>Observable Behavior</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Service Type</td>
                                    <td>Stateless</td>
                                    <td>Any instance can serve requests immediately after restart; no synchronization required</td>
                                </tr>
                                <tr>
                                    <td>Service Type</td>
                                    <td>Stateful</td>
                                    <td>Instances must coordinate state; restart may require synchronization</td>
                                </tr>
                                <tr>
                                    <td>Concurrency Model</td>
                                    <td>Best Effort</td>
                                    <td>Requests complete quickly; temporary inconsistency between instances is possible</td>
                                </tr>
                                <tr>
                                    <td>Concurrency Model</td>
                                    <td>Transactional</td>
                                    <td>Requests are acknowledged only after all peers are synchronized; strong consistency</td>
                                </tr>
                                <tr>
                                    <td>Concurrency Model</td>
                                    <td>Replication Count X</td>
                                    <td>Requests complete after X replicas acknowledge; tunable consistency vs latency</td>
                                </tr>
                                <tr>
                                    <td>Leadership</td>
                                    <td>None</td>
                                    <td>Requests may be handled by any instance</td>
                                </tr>
                                <tr>
                                    <td>Leadership</td>
                                    <td>Elected Leader</td>
                                    <td>All writes are routed through the leader; leadership may change transparently</td>
                                </tr>
                                <tr>
                                    <td>Replication</td>
                                    <td>Disabled</td>
                                    <td>Single authoritative instance per Service Item</td>
                                </tr>
                                <tr>
                                    <td>Replication</td>
                                    <td>Enabled</td>
                                    <td>Multiple replicas exist; placement and count are enforced by the platform</td>
                                </tr>
                                <tr>
                                    <td>Failure Handling</td>
                                    <td>Instance Failure</td>
                                    <td>Instance is replaced without changing service identity</td>
                                </tr>
                                <tr>
                                    <td>Failure Handling</td>
                                    <td>Leader Failure</td>
                                    <td>New leader is elected without client-visible disruption</td>
                                </tr>
                                <tr>
                                    <td>Acknowledgement</td>
                                    <td>Immediate</td>
                                    <td>Caller may observe stale reads briefly</td>
                                </tr>
                                <tr>
                                    <td>Acknowledgement</td>
                                    <td>Post-Sync</td>
                                    <td>Caller observes only committed, synchronized state</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <hr>

                    <h2>Concurrency as a Service</h2>

                    <blockquote>
                        <p>In Layer 8, concurrency is not implemented by application logic.<br>
                        It is not reinvented per service.<br>
                        It is not guessed at runtime.</p>
                    </blockquote>

                    <p>Concurrency is declared as part of the SLA and enforced by the platform.</p>

                    <p>The service expresses intent. Layer 8 applies the contract.</p>

                    <p><strong>Concurrency is served, not invented.</strong></p>

                    <h3>What Application Code No Longer Implements</h3>

                    <p>Because service behavior in Layer 8 is declared through the SLA and enforced by the platform, application code is no longer responsible for implementing core operational concerns.</p>

                    <p>Specifically, application code does not implement:</p>

                    <ul>
                        <li>concurrency control or locking semantics,</li>
                        <li>leader election or leadership failover,</li>
                        <li>replication coordination or quorum handling,</li>
                        <li>state synchronization between instances,</li>
                        <li>cache coherence or defensive copying,</li>
                        <li>retry logic to compensate for partial failure,</li>
                        <li>idempotency guards for repeated requests,</li>
                        <li>instance discovery or peer awareness,</li>
                        <li>lifecycle reconciliation after restarts or crashes.</li>
                    </ul>

                    <p>Application code is limited to expressing domain behavior against a single logical service abstraction.</p>

                    <p>Operational correctness is guaranteed by the platform, not reimplemented by each service. As a result, service implementations remain small, deterministic, and independent of deployment topology.</p>

                    <hr>

                    <h2>Base Service</h2>

                    <p>As Layer 8 evolved, and more infrastructure services were built using the same design guidelines, a pattern began to emerge.</p>

                    <p>Service implementations were repeating themselves.</p>

                    <p>Further coherence analysis revealed that, across services, most of the implementation code was effectively identical.</p>

                    <p>Only the declared intent and the SLA varied from one service to another.</p>

                    <p>Through repeated cycles of:</p>

                    <ul>
                        <li>coherence analysis,</li>
                        <li>refactoring,</li>
                        <li>and revalidation,</li>
                    </ul>

                    <p>the Layer 8 Base Service emerged.</p>

                    <p>The Base Service captures common behavior in a single, generic, well-tested implementation.</p>

                    <p>As a result, implementing a service no longer requires writing service logic.</p>

                    <p>A service is defined by declaring its SLA.</p>

                    <p>The platform provides the rest.</p>

                    <h3>Distributed Cache</h3>

                    <p>At the core of the Base Service is a Distributed Cache designed for correctness under concurrency.</p>

                    <p>The cache guarantees both thread safety and safe concurrent modification by combining two techniques:</p>

                    <ul>
                        <li>mutex-based synchronization,</li>
                        <li>and defensive cloning.</li>
                    </ul>

                    <p>A read-write mutex allows multiple goroutines to read concurrently, while ensuring that write operations have exclusive access.</p>

                    <p>However, mutexes alone are not sufficient.</p>

                    <p>Even with proper locking, a caller could modify an object after retrieving it from the cache, silently corrupting shared state.</p>

                    <p>To prevent this, the cache clones every value:</p>

                    <ul>
                        <li>once when storing it,</li>
                        <li>and again when retrieving it.</li>
                    </ul>

                    <p>Callers always interact with independent copies. They never receive direct references to cached data.</p>

                    <p>This design guarantees that:</p>

                    <ul>
                        <li>changes made by one goroutine never affect others,</li>
                        <li>shared state cannot be corrupted accidentally,</li>
                        <li>and callers do not need to manage synchronization themselves.</li>
                    </ul>

                    <p>The result is complete isolation with minimal cognitive overhead.</p>

                    <p>The Base Service embodies the core philosophy of Layer 8:</p>

                    <ul>
                        <li>declare intent,</li>
                        <li>enforce guarantees,</li>
                        <li>and eliminate accidental complexity.</li>
                    </ul>

                    <hr>

                    <h2>Service Manager</h2>

                    <blockquote>
                        <p>The Service Manager is responsible for the lifecycle of a service.</p>
                    </blockquote>

                    <p>It orchestrates service activation, coordination, and termination, and acts as the control plane that binds together the core Layer 8 subsystems.</p>

                    <p>Specifically, the Service Manager coordinates between:</p>

                    <ul>
                        <li>the Secure Virtual Network Overlay,</li>
                        <li>the security guidelines and policies,</li>
                        <li>and the declared concurrency model defined by the service SLA.</li>
                    </ul>

                    <p>The Service Manager maintains the Service Participant Peer Registry, tracking all active instances participating in a service.</p>

                    <p>When required by the SLA, it performs leader election and manages leadership transitions transparently.</p>

                    <p>Leadership is treated as a role, not as an identity, and can move without changing the service facade.</p>

                    <p>Through this mechanism, services remain:</p>

                    <ul>
                        <li>logically singular,</li>
                        <li>operationally distributed,</li>
                        <li>and compliant with their declared guarantees.</li>
                    </ul>

                    <p>The Service Manager ensures that service behavior follows intent, <strong>not deployment artifacts</strong>.</p>

                    <hr>

                    <h2>Replication Index Service</h2>

                    <p>When a service declares sharding or a replication count as part of its SLA, Layer 8 provides a built-in Replication Index Service.</p>

                    <p>This service tracks and coordinates replication according to the guarantees defined by the SLA.</p>

                    <p>When replication is enabled, the Replication Index Service is activated automatically.</p>

                    <p>It maintains a consistent view of:</p>

                    <ul>
                        <li>which service instances hold replicas,</li>
                        <li>how many replicas exist for each Service Item,</li>
                        <li>and how replication responsibilities are distributed.</li>
                    </ul>

                    <p>The Replication Index Service works in coordination with:</p>

                    <ul>
                        <li>the Service Manager,</li>
                        <li>the declared concurrency model,</li>
                        <li>and the Secure Virtual Network Overlay.</li>
                    </ul>

                    <p>Replication state is not inferred. It is explicitly tracked and enforced.</p>

                    <p>By externalizing replication coordination into a dedicated service, Layer 8 avoids embedding replication logic into application code.</p>

                    <p>Replication is declared.<br>
                    The index is maintained.<br>
                    Consistency follows the contract.</p>

                    <nav class="chapter-nav">
                        <a href="model-agnostic-runtime.html" class="prev">Model-Agnostic Runtime</a>
                        <span class="placeholder next">Next Chapter</span>
                    </nav>
                </article>
            </div>
        </main>
    </div>

    <script src="js/book.js"></script>
</body>
</html>
