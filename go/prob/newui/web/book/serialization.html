<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#fdfbf7">
    <meta name="description" content="Serialization | Radical Simplicity for Humans by Sharon Aicler">
    <meta name="author" content="Sharon Aicler">
    <title>Serialization | Radical Simplicity for Humans</title>
    <link rel="stylesheet" href="css/book.css">
</head>
<body>
    <button class="mobile-nav-toggle" aria-label="Toggle navigation">
        <span></span>
        <span></span>
        <span></span>
    </button>
    <div class="sidebar-overlay"></div>

    <div class="site-container">
        <nav class="sidebar" role="navigation" aria-label="Table of Contents">
            <header class="site-header">
                <h1 class="book-title">Radical Simplicity<br>for Humans</h1>
                <p class="book-subtitle">Layer 8</p>
                <div class="author-info">
                    <p>Sharon Aicler</p>
                    <p><a href="mailto:saichler@gmail.com">saichler@gmail.com</a></p>
                </div>
                <div class="sponsor-button">
                    <iframe src="https://github.com/sponsors/saichler/button" title="Sponsor saichler" height="32" width="114" style="border: 0; border-radius: 6px;"></iframe>
                </div>
            </header>

            <h2 class="nav-title">Contents</h2>
            <ul class="chapter-list">
                <li><a href="book.html">Home</a></li>
                <li><a href="about.html">About the Author</a></li>
                <li><a href="introduction.html">Introduction</a></li>
                <li><a href="thoughts.html">Thoughts</a></li>
                <li><a href="ground-rules.html">Ground Rules</a></li>
                <li><a href="architecture.html">Architecture Is the Alignment Mechanism</a></li>
                <li><a href="failure-modes.html">Failure Modes</a></li>
                <li><a href="economics.html">Economics</a></li>
                <li><a href="security.html">Security</a></li>
                <li><a href="networking.html">Networking</a></li>
                <li><a href="serialization.html" class="active">Serialization</a></li>
                <li><a href="model-agnostic-runtime.html">Model-Agnostic Runtime</a></li>
                <li><a href="service-as-contract.html">Service as a Contract</a></li>
                <li><span class="coming-soon">API &amp; Query Language</span></li>
                <li><span class="coming-soon">Object Relation Mapping</span></li>
                <li><span class="coming-soon">Web Server</span></li>
                <li><span class="coming-soon">Quality</span></li>
                <li><span class="coming-soon">Migration</span></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="content-wrapper">
                <article>
                    <h1>Serialization</h1>

                    <h2>The Act of Serialization</h2>

                    <p>When a process wants to share part of its in-memory state with another process, it must convert that state into a sequence of bytes and transmit it over the wire. The receiving side must then reconstruct a usable representation from those bytes.</p>

                    <p><strong>This act is called serialization.</strong></p>

                    <p>In most systems, serialization is implemented directly inside application code:</p>

                    <ul>
                        <li>the provider explicitly converts a model into bytes,</li>
                        <li>the consumer explicitly converts bytes back into a model.</li>
                    </ul>

                    <p>As a result, application logic, transport concerns, and model evolution become tightly coupled.</p>

                    <hr>

                    <h2>Serialization and Symmetry</h2>

                    <p>Serialization always implies symmetry. The sender and receiver must agree on the meaning and structure of the data being exchanged. There is no such thing as serialization without symmetry.</p>

                    <p>The failure mode in distributed systems is not the existence of symmetry. It is the fact that symmetry is enforced manually, repeatedly, and inconsistently across applications.</p>

                    <p>When every provider and consumer implements its own serialization and deserialization logic:</p>

                    <ul>
                        <li>model evolution must be coordinated across codebases,</li>
                        <li>version mismatches surface at runtime,</li>
                        <li>serialization bugs are duplicated across services,</li>
                        <li>and application developers are burdened with infrastructure concerns.</li>
                    </ul>

                    <p>Serialization and deserialization should be infrastructure-owned, not application-owned, because duplicating this logic across teams multiplies complexity, forces correlated code changes and delivery timelines, and turns model evolution into an organizational bottleneck rather than a platform concern.</p>

                    <hr>

                    <h2>What Layer 8 Changes</h2>

                    <p>Layer 8 does not attempt to weaken or avoid serialization symmetry. Instead, it removes serialization and deserialization from application code entirely.</p>

                    <p>Both providers and consumers are decoupled from the model-to-bytes and bytes-to-model transformations. Applications are responsible only for understanding and applying domain logic to models.</p>

                    <p>Understanding means that both the provider and the consumer know the model and agree on what each attribute represents and what its logical value means. It does not include any responsibility for encoding or decoding bytes.</p>

                    <p>Serialization becomes a platform capability.</p>

                    <p>In Layer 8:</p>

                    <ul>
                        <li>the provider hands a model instance to the platform,</li>
                        <li>the platform serializes it for transport,</li>
                        <li>the receiving platform deserializes the payload,</li>
                        <li>and the consumer receives a usable representation without performing any decoding logic.</li>
                    </ul>

                    <p>This separation allows symmetry to be enforced centrally and consistently, rather than being hand-maintained in every service.</p>

                    <h3>Responsibility Boundary Diagram</h3>

                    <figure class="diagram">
                        <img src="images/ser.png" alt="Serialization Responsibility Boundary Diagram" style="max-width: 70%;">
                    </figure>

                    <p><em>Figure: Service-to-service communication with serialization, messaging, and deserialization fully owned by Layer 8.</em></p>

                    <p>This diagram makes responsibility boundaries explicit. Applications never interact with bytes. All model-to-bytes and bytes-to-model transformations are owned by Layer 8 and mediated through Vnet Messaging.</p>

                    <hr>

                    <h2>Type Registry</h2>

                    <p>Because serialization is no longer owned by either the provider or the consumer, Layer 8 requires an authoritative mechanism to resolve type identity and reconstruction.</p>

                    <p><strong>This is the role of the Type Registry.</strong></p>

                    <p>The Type Registry is authoritative over:</p>

                    <ul>
                        <li>type identity carried on the wire,</li>
                        <li>the mapping between type identifiers and model definitions,</li>
                        <li>serializer and deserializer selection,</li>
                        <li>and the rules required to reconstruct models independently of application code.</li>
                    </ul>

                    <p>The registry allows Layer 8 to deserialize payloads even when the consuming application did not compile against the concrete model type.</p>

                    <p>Deserialization produces a model instance or a model-agnostic representation that can be routed, inspected, stored, forwarded, or later bound to domain logic.</p>

                    <p>Understanding the model is optional and occurs only when the application needs to apply business behavior.</p>

                    <p>The mechanics that make this possible, including model-agnostic representations, runtime type resolution, and delta calculation, are explored in depth in the <strong>Model-Agnostic Runtime: Data Without Schemas</strong> chapter.</p>

                    <h2>JSON vs. Protocol Buffers</h2>

                    <p>JSON is one of the most commonly used serialization formats today. It is heavily used for communication with user interfaces and external systems.</p>

                    <p>Consider the following JSON example:</p>

<pre><code>{
  "employees": [
    {
      "id": 101,
      "name": "Alice Johnson",
      "role": "Software Engineer",
      "department": "Platform"
    },
    {
      "id": 102,
      "name": "Bob Martinez",
      "role": "DevOps Engineer",
      "department": "Infrastructure"
    },
    {
      "id": 103,
      "name": "Carol Lee",
      "role": "Product Manager",
      "department": "Product"
    }
  ]
}</code></pre>

                    <p>Beyond the raw data itself, JSON carries significant structural overhead. Field names and delimiters are repeated throughout the message, increasing payload size and CPU cost.</p>

                    <p>Protocol Buffers take a different approach. When both sides already know the order and meaning of fields, the wire format does not need to repeatedly encode labels.</p>

                    <p>Illustratively (this is not the exact wire format), the same data could look like this:</p>

<pre><code>101Alice JohnsonSoftware EngineerPlatform102Bob MartinezDevOps EngineerInfrastructure103Carol LeeProduct ManagerProduct</code></pre>

                    <h2>Protobuf Object &mdash; Delta Updates</h2>

                    <p>In real systems, models are complex and deeply nested. They change frequently, but rarely in their entirety.</p>

                    <p>Traditional serializers retransmit full objects even when only a small subset of fields has changed.</p>

                    <p>This is not merely an inefficiency. It has direct economic consequences.</p>

                    <h3>Economic Impact of Full-Object Updates</h3>

                    <p>Full-object retransmission increases cost along three dimensions:</p>

                    <ul>
                        <li><strong>Bandwidth</strong>: unnecessary bytes consume network capacity and increase egress costs.</li>
                        <li><strong>CPU</strong>: repeated serialization and deserialization of unchanged data wastes compute cycles.</li>
                        <li><strong>Coordination</strong>: large payloads amplify the impact of schema changes, increasing the risk and cost of evolution.</li>
                    </ul>

                    <p>Because serialization and deserialization are owned by the platform rather than individual applications, Layer 8 can address these costs structurally, instead of forcing every team to re-implement optimization logic or coordinate schema changes across services.</p>

                    <p>Layer 8 introduces the concept of the <strong>Protobuf Object</strong> to address this structurally.</p>

                    <p>A Protobuf Object is a serializer that understands how to:</p>

                    <ul>
                        <li>serialize any model instance or attribute,</li>
                        <li>calculate changes between versions,</li>
                        <li>and transmit only the delta.</li>
                    </ul>

                    <h3>Why Deltas Matter</h3>

                    <p>Delta-based updates reduce bandwidth by transmitting only what changed. They reduce CPU usage by avoiding repeated processing of unchanged fields.</p>

                    <p>More importantly, they reduce coordination cost. When only changes cross service boundaries, model evolution becomes localized. Small changes remain small.</p>

                    <p>This shifts the economics of distributed systems:</p>

                    <ul>
                        <li>bandwidth scales with change, not model size,</li>
                        <li>CPU cost scales with mutation, not state,</li>
                        <li>and schema evolution no longer requires synchronized, system-wide agreement.</li>
                    </ul>

                    <p>By avoiding full-object retransmission, Layer 8 limits the blast radius of change and improves both technical scalability and organizational velocity.</p>

                    <p>The mechanics of model-delta calculation are discussed in the <strong>Model-Agnostic Runtime: Data Without Schemas</strong> chapter.</p>

                    <hr>

                    <h2>Elements</h2>

                    <p>Service interactions vary widely. Some operations return a single result. Others return collections, streams, or errors.</p>

                    <p>Handling these variations typically leads to fragmented APIs and special-case logic.</p>

                    <p>Layer 8 introduces the concept of <strong>Elements</strong> to normalize these interactions.</p>

                    <p>Elements provide a consistent envelope for requests and responses, independent of cardinality or operation type. They allow consumers to reason about interactions uniformly, while Layer 8 handles serialization, transport, and reconstruction.</p>

                    <p>Centralizing serialization and deserialization in Layer 8 establishes a foundation for controlled runtime evolution, efficient delta-based updates, and uniform service interactions. By removing serialization mechanics from application code, Layer 8 enables models to evolve without coordinated redeployments, limits the cost and blast radius of change through deltas, and provides a consistent envelope for APIs via Elements. Together, these properties shift distributed systems from fragile, coordination-heavy designs to architectures where change is expected, bounded, and economically sustainable.</p>

                    <p>Elements play a central role in Layer 8 APIs and are explored further in the <strong>API &amp; Query Language</strong> chapter.</p>

                    <nav class="chapter-nav">
                        <a href="networking.html" class="prev">Networking</a>
                        <a href="model-agnostic-runtime.html" class="next">Model-Agnostic Runtime</a>
                    </nav>
                </article>
            </div>
        </main>
    </div>

    <script src="js/book.js"></script>
</body>
</html>
