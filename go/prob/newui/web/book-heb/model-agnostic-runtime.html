<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#fdfbf7">
    <meta name="description" content="זמן ריצה אגנוסטי למודל: נתונים ללא סכמות | פשטות רדיקלית לבני אדם מאת שרון אייכלר">
    <meta name="author" content="שרון אייכלר">
    <title>זמן ריצה אגנוסטי למודל: נתונים ללא סכמות | פשטות רדיקלית לבני אדם</title>
    <link rel="stylesheet" href="css/book.css">
</head>
<body>
    <button class="mobile-nav-toggle" aria-label="פתח/סגור תפריט">
        <span></span>
        <span></span>
        <span></span>
    </button>
    <div class="sidebar-overlay"></div>

    <div class="site-container">
        <nav class="sidebar" role="navigation" aria-label="תוכן עניינים">
            <header class="site-header">
                <h1 class="book-title">פשטות רדיקלית<br>לבני אדם</h1>
                <p class="book-subtitle">שכבה 8</p>
                <div class="author-info">
                    <p>שרון אייכלר</p>
                    <p><a href="mailto:saichler@gmail.com">saichler@gmail.com</a></p>
                </div>
                <div class="sponsor-button">
                    <iframe src="https://github.com/sponsors/saichler/button" title="Sponsor saichler" height="32" width="114" style="border: 0; border-radius: 6px;"></iframe>
                </div>
            </header>

            <h2 class="nav-title">תוכן עניינים</h2>
            <ul class="chapter-list">
                <li><a href="book.html">בית</a></li>
                <li><a href="about.html">אודות המחבר</a></li>
                <li><a href="introduction.html">מבוא</a></li>
                <li><a href="thoughts.html">מחשבות</a></li>
                <li><a href="ground-rules.html">כללי יסוד</a></li>
                <li><a href="architecture.html">ארכיטקטורה כמנגנון יישור</a></li>
                <li><a href="failure-modes.html">מצבי כשל</a></li>
                <li><a href="economics.html">כלכלה</a></li>
                <li><a href="security.html">אבטחה</a></li>
                <li><a href="networking.html">רשתות</a></li>
                <li><a href="serialization.html">סריאליזציה</a></li>
                <li><a href="model-agnostic-runtime.html" class="active">זמן ריצה אגנוסטי למודל</a></li>
                <li><a href="service-as-contract.html">שירות כחוזה</a></li>
                <li><a href="api-query-language.html">API ושפת שאילתות</a></li>
                <li><a href="object-relation-mapping.html">מיפוי יחסי אובייקטים</a></li>
                <li><a href="web-server.html">שרת אינטרנט</a></li>
                <li><a href="quality.html">איכות</a></li>
                <li><a href="practice.html">תרגול</a></li>
                <li><span class="coming-soon">פשטות רדיקלית לבינה מלאכותית</span></li>
                <li><span class="coming-soon">מיגרציה</span></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="content-wrapper">
                <article>
                    <h1>זמן ריצה אגנוסטי למודל: נתונים ללא סכמות</h1>

                    <p>פרק זה אינו עוסק בהסרת סכמות. הוא עוסק בהסרת לוגיקה משוכפלת.</p>

                    <p>במערכות מסורתיות, כל אפליקציה שמחזיקה מודל בזיכרון או במטמון חייבת ליישם באופן עצמאי את אותן אחריויות:</p>

                    <ul>
                        <li>ניווט במבנים מקוננים עמוקות</li>
                        <li>מעקב אחר שינויים בין מופעי מודל</li>
                        <li>החלת עדכונים חלקיים בבטחה</li>
                        <li>התאמת מקביליות ומעברי מצב</li>
                        <li>שחזור מצב מודל לאחר שמירה או תחבורה</li>
                    </ul>

                    <p>לוגיקה זו חוזרת על עצמה בין שירותים, צוותים ושכבות. היא עדינה, שבירה ויקרה לתחזוקה.</p>

                    <p>שכבה 8 מזהה אחריויות אלה כמורכבות מבנית ומכמסת אותן לתוך רכיב יחיד ואגנוסטי למודל, ומסירה אותן לחלוטין מקוד האפליקציה.</p>

                    <p>במקום שכל אפליקציה תתחזק לוגיקה מפורשת משלה לניווט מודל, השוואה, מוטציה וסנכרון, אחריות זו מועברת למנגנוני תשתית שהם:</p>

                    <ul>
                        <li>אגנוסטיים למודל</li>
                        <li>דטרמיניסטיים</li>
                        <li>מוגבלים במפורש</li>
                        <li>בבעלות מרכזית</li>
                    </ul>

                    <p>מעבר זה מסיר מחלקות שלמות של קוד אפליקציה משוכפל. טיפול במצב מודל הופך לדאגת פלטפורמה ולא לדאגת אפליקציה.</p>

                    <p>בהמשך הארכיטקטורה, אותו מנגנון נמצא בשימוש חוזר על ידי שכבת ה-ORM, מה שהופך את השמירה עצמה לאגנוסטית למודל. זה מבטל עוד יותר לוגיקה הקשורה לסכמה, סריאלייזרים, ממפים וקוד התאמה כתוב ידנית.</p>

                    <p>התוצאה אינה הפשטה מוגברת. היא פחות קוד, פחות מצבי כשל ועומס קוגניטיבי נמוך יותר.</p>

                    <p>סכמות לא מוסרות. הן פשוט לא מיושמות מחדש בכל מקום.</p>

                    <hr>

                    <h2>סמכות מרכזית, נכונות שמורה</h2>

                    <p>ריכוז טיפול במחזור חיי המודל אינו מרפה נכונות. הוא משנה היכן מבנה, ולידציה ומקביליות נאכפים.</p>

                    <p>במערכות מסורתיות, אחריויות אלה משוכפלות בין אפליקציות דרך סכמות, ממפים, סריאלייזרים, מטמונים ולוגיקת התאמה כתובה ידנית. כל אפליקציה חייבת לתחזק באופן עצמאי את הפרשנות שלה למבנה מודל, מעברי מצב ונכונות תחת מקביליות.</p>

                    <p>שכבה 8 מסירה שכפול זה על ידי אכיפת אחריויות אלה פעם אחת, באופן מרכזי.</p>

                    <p>מכיוון שניווט מודל, מוטציה וסנכרון בבעלות מנגנון יחיד ואגנוסטי למודל, האילוצים הבאים נאכפים באופן אחיד:</p>

                    <ul>
                        <li>צורת מודל וגבולות שדות מתגלים דרך אינטרוספקציה ולא ניתנים להמצאה שרירותית.</li>
                        <li>מידע סוג נשמר ונאכף במהלך פעולות קריאה, כתיבה, השוואה ועדכון.</li>
                        <li>פעולות עדכון מוגבלות למאפיינים תקפים וניתנים לכתובת שמוגדרים על ידי תוכנית זמן הריצה.</li>
                        <li>מקביליות נאכפת דרך עדכוני דלתא דטרמיניסטיים הנגזרים ממצב מודל סמכותי.</li>
                        <li>סמנטיקת ולידציה, שוויון ושיבוט נשארות מפורשות ומכוונות, לא תופעות לוואי מתהוות.</li>
                    </ul>

                    <p>ערבויות אלה אינן אופציונליות. הן מאפיינים מבניים של הפלטפורמה ונאכפות פעם אחת, באופן מרכזי.</p>

                    <p>ארכיטקטורות מסורתיות דורשות שערבויות אלה ייושמו מחדש בכל אפליקציה דרך סכמות בזמן קומפילציה והגדרות מודל משותפות. שכבה 8 אוכפת את אותן ערבויות מבלי לכפות תלויות קומפילציה משותפות.</p>

                    <p>במקום להסתמך על תוכנית מוגדרת מראש, שכבה 8 קוראת את המודל בזמן ריצה. זה מאפשר לה להעתיק, להשוות, לעדכן ולחפש בנתונים מכל צורה או מורכבות, כולל מודלים שלא ראתה קודם, תוך שמירה על נכונות.</p>

                    <p>עם רמזים קטנים ומכוונים שנוספים למודל, הנקראים דקורטורים, שכבה 8 מקבלת מספיק הקשר כדי לנהל נתוני מודל בבטחה בין אלמנטי מערכת מבוזרת.</p>

                    <p>לא נדרשת סכמה בזמן קומפילציה. לא נאכפות הגדרות מודל משותפות בין רכיבים.</p>

                    <p>התוצאה היא זמן ריצה אגנוסטי למודל: מנוע נתונים אוניברסלי שיכול לנתח מצב מודל מבלי לצמד אפליקציות ללוגיקה ספציפית למבנה.</p>

                    <p>גישה זו מאתגרת הנחות שמושרשות עמוק בתכנון תוכנה מסורתי. ברגע שמבינים אותה, היא מסירה מחלקות שלמות של מורכבות ממערכות מבוזרות.</p>

                    <hr>

                    <h2>אינטרוספקטור</h2>

                    <p>אינטרוספקציה היא היכולת לבחון את המבנה, מידע הסוג והמאפיינים של אובייקט בזמן ריצה.</p>

                    <p>שכבה 8 משתמשת באינטרוספקציה כדי לבנות תוכנית זמן ריצה של המודל.</p>

                    <p>תוכנית זו אינה סכמה סטטית. היא ייצוג חי של המודל כפי שהוא קיים בזמן ריצה.</p>

                    <p>רכיבי שכבה 8 צורכים תוכנית זו כמקור אמת משותף. שירותים גנריים ואגנוסטיים למודל משתמשים בה כדי להעתיק, להשוות, לעדכן, לאמת ולשמור מופעי מודל בין תהליכים מבוזרים.</p>

                    <p>על ידי הסתמכות על אינטרוספקציה במקום לוגיקה מקודדת קשיח, שכבה 8 מסירה את הצורך במכניקות ספציפיות למודל ברכיבי תשתית.</p>

                    <p>האינטרוספקטור של שכבה 8 הוא המנגנון המרכזי שבונה ומתחזק תוכנית זו.</p>

                    <hr>

                    <h2>דוגמה מעשית: מאינטרוספקציה לעדכון דלתא</h2>

                    <p>נניח מופע מודל בזמן ריצה:</p>

<pre><code>Device {
  Id: "r1",
  State: {
    AdminUp: true,
    Metrics: {
      Cpu: 42
    }
  }
}</code></pre>

                    <h3>שלב 1: אינטרוספקציה</h3>

                    <p>האינטרוספקטור מייצר תוכנית זמן ריצה:</p>

                    <ul>
                        <li>Device.Id (string)</li>
                        <li>Device.State.AdminUp (bool)</li>
                        <li>Device.State.Metrics.Cpu (int)</li>
                    </ul>

                    <h3>שלב 2: שינוי מודל</h3>

<pre><code>Cpu: 55</code></pre>

                    <h3>שלב 3: חישוב דלתא</h3>

<pre><code>PropertyId: Device.State.Metrics.Cpu
OldValue: 42
NewValue: 55</code></pre>

                    <h3>שלב 4: החלת דלתא</h3>

                    <p>הצד המקבל פותר את ה-PropertyId ומחיל את העדכון בבטחה באמצעות אותה תוכנית.</p>

                    <p>זהו דפוס הליבה שחוזר לאורך שכבה 8: בצע אינטרוספקציה פעם אחת, נתח באופן גנרי, והעבר רק את האמת המינימלית הנדרשת.</p>

                    <h3>מצבי כשל שבוטלו</h3>

                    <p>מנגנון זה מבטל ישירות מספר מצבי כשל שהוצגו בפרק 04:</p>

                    <ul>
                        <li>צימוד מקרי</li>
                        <li>בעלות משתמעת</li>
                        <li>דליפת מקביליות</li>
                        <li>שבריריות בדיקות</li>
                    </ul>

                    <hr>

                    <h2>מקביליות &mdash; מעדכן</h2>

                    <p>אחת הבעיות הקשות ביותר במערכות מבוזרות היא שמירה על מודל משותף עקבי בין תהליכים.</p>

                    <p>ברמה גבוהה, יש רק שתי דרכים לעשות זאת:</p>

                    <ul>
                        <li>לשדר את מופע המודל השלם ולהחליף אותו</li>
                        <li>לשדר רק את השינויים ולהחיל אותם באופן מצטבר</li>
                    </ul>

                    <p>הגישה הראשונה פשוטה ויקרה. הגישה השנייה יעילה אך מסורתית שבירה.</p>

                    <p>שכבה 8 מציגה את המעדכן.</p>

                    <p>המעדכן הוא רכיב גנרי ואגנוסטי למודל. הוא מקבל שני מופעים של אותו מודל ומשתמש בתוכנית האינטרוספקציה כדי להפוך מופע אחד לאחר.</p>

                    <p><strong>התוצאה היא רשימה דטרמיניסטית של שינויים, כל אחד מבוטא כעדכון מאפיין ניתן לכתובת.</strong></p>

                    <hr>

                    <h2>מאפיין</h2>

                    <p>מאפיין הוא עטיפת תכונה-מופע הבנויה על גבי תוכנית האינטרוספקציה.</p>

                    <p>מאפיין מייצג את כל מה שנדרש כדי להגיע ולשנות תכונה ספציפית בתוך מופע מודל:</p>

                    <ul>
                        <li>נתיב הניווט המלא משורש המודל</li>
                        <li>כתובת יציבה דרך PropertyId</li>
                        <li>גישות Getter ו-Setter</li>
                    </ul>

                    <p>מאפיינים ממטריאליזים אוטומטית מבנים ביניים חסרים. לא נדרשת לוגיקת מקרה מיוחד.</p>

                    <p>מאפיין הוא אבן הבניין האחרונה שהופכת מקביליות אגנוסטית למודל ומבוססת דלתא לסקיילבילית ופשוטה כאחד.</p>

                    <hr>

                    <h2>שיבוט עמוק והשוואה עמוקה</h2>

                    <p>שיבוט והשוואה אינם פעולות טכניות גרידא. הם החלטות עיצוביות.</p>

                    <p>מימושי שיבוט עמוק והשוואה עמוקה גנריים מתייחסים לכל הנתונים כשווים מבנית. הם אינם יכולים להבחין בין נתונים שהם מסודרים, לא מסודרים, סמכותיים, נגזרים או שווים סמנטית.</p>

                    <p>שקלו את הדוגמה הבאה:</p>

<pre><code>[]int{1, 2, 3}</code></pre>

                    <p>בהשוואה ל:</p>

<pre><code>[]int{3, 2, 1}</code></pre>

                    <p><strong>האם ערכים אלה שווים?</strong></p>

                    <p>אין תשובה נכונה אוניברסלית.</p>

                    <p>בחלק מהמודלים, סדר הוא משמעותי וערכים אלה שונים. במודלים אחרים, הרשימה מייצגת קבוצה, והסדר אינו רלוונטי.</p>

                    <p>הפרשנות הנכונה תלויה בכוונת המודל, לא במבנה או בסוג בלבד.</p>

                    <p>כאשר לוגיקת שיבוט או השוואה מיושמת בקוד אפליקציה, כוונה זו חייבת להיות מקודדת מחדש שוב ושוב, בחוסר עקביות ובאופן משתמע.</p>

                    <p>שכבה 8 מרכזת סמנטיקת שיבוט ושוויון כך שהחלטות אלה מבוטאות פעם אחת, בכוונה, ונאכפות באופן אחיד.</p>

                    <p>על ידי התייחסות לשיבוט עמוק והשוואה עמוקה כחלק ממחזור חיי המודל, שכבה 8 מונעת מהחלטות סמנטיות לדלוף לקוד אפליקציה.</p>

                    <p>זה מבטיח נכונות ככל שמודלים מתפתחים, מבלי להחזיר לוגיקה משוכפלת או עמימות מבוזרת.</p>

                    <nav class="chapter-nav">
                        <a href="serialization.html" class="prev">סריאליזציה</a>
                        <a href="service-as-contract.html" class="next">שירות כחוזה</a>
                    </nav>
                </article>
            </div>
        </main>
    </div>

    <script src="js/book.js"></script>
</body>
</html>
